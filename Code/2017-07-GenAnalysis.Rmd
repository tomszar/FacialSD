---
title: Genetic clustering
output: 
  html_document:
    fig_height: 10
    fig_width: 10
---

In this script we will look at some descriptive statistics from the genetic PCA, previously done in Plink, and Admixture analysis.
The steps to create the genetic PCA were as following:

- Remove of missing genotype data.
- LD pruning using a window size of 10kb and a VIF of 2.
- Only 1000Genomes samples were used to create the PCA, and our samples were projected there.
- A total of 50 PCs were extracted

## Preliminaries

Calling libraries and datasets

```{r libraries datasets, warning=FALSE, message=FALSE}
library(ggplot2)
library(dplyr)
library(GGally)
library(ggpubr)
library(caret)
library(pophelper)
library(gridExtra)

setwd('..')
path <- getwd()
setwd(paste(path, "/Results/GenPCA", sep = ""))
pca.eigenval <- read.csv("PCA.eigenval", sep = "", header = F)
pca.eigenvec <- read.csv("PCA.eigenvec", sep = "", header = F)
PCnames      <- sprintf("PC%s",seq(1:50))
colnames(pca.eigenvec) <- c("FID", "IID", PCnames)

setwd(paste(path, "/Results/MergeGeno/Merge1000G", sep = ""))
pops <- read.csv("integrated_call_samples_v3.20130502.ALL.panel", sep = "")
colnames(pops)[1] <- "IID"

setwd(paste(path, "/Results/Admixture", sep = ""))
admix <- readQ("Merge1000Gsamples.6.Q")
#Removing duplicates
admix[[1]]   <- admix[[1]][!duplicated(pca.eigenvec$IID), ] 
pca.eigenvec <- pca.eigenvec[!duplicated(pca.eigenvec$IID), ] 

rownames(admix[[1]]) <- pca.eigenvec$IID
```

## Data cleaning

Creating new columns to plot 1000Genomes pops against our samples more easily.

```{r new column}
pca.eigenvec$FID <- as.character(pca.eigenvec$FID)
for(i in 1:nrow(pca.eigenvec)){
  if(pca.eigenvec$IID[i] %in% pops$IID){
    ind <- match(pca.eigenvec$IID[i], pops$IID)
    pca.eigenvec$FID[i] <- as.character(pops$pop[ind])
  }
}
pca.eigenvec$FID <- as.factor(pca.eigenvec$FID)
pca.eigenvec$pop <- pca.eigenvec$FID 
pca.eigenvec$pop[!(pca.eigenvec$FID %in% pops$pop)] <- "ADAPT"
pca.eigenvec$pop <- droplevels(pca.eigenvec$pop)

pca.eigenvec$super_pop <- as.character(pca.eigenvec$pop)
for(i in 1:nrow(pca.eigenvec)){
  if(pca.eigenvec$IID[i] %in% pops$IID){
    ind <- match(pca.eigenvec$IID[i], pops$IID)
    pca.eigenvec$super_pop[i] <- as.character(pops$super_pop[ind])
  }
}
pca.eigenvec$super_pop <- as.factor(pca.eigenvec$super_pop)
```

Because plink output is a normalized PCA, we de-normalized the PCA by multiplying the eigenvectors by the standard deviation.

```{r de-normalizing PCA}
pca.eigenvec[,3:52] <- t(c(as.matrix(pca.eigenval)) * t(as.matrix(pca.eigenvec[,3:52])))
```

## Descriptive and exploratory analyses

Some summary stats

```{r summary}
summary(pca.eigenvec[,c(1,2,53,54)])
```
 
PCA screeplot

```{r screeplot, fig.height=4, fig.width=8} 
barplot(c(as.matrix(pca.eigenval)), names.arg=PCnames, 
       main = "Variances",
       xlab = "Principal Components",
       ylab = "Eigenvalue",
       col = "steelblue")
```

Looking at the 1000Genomes populations: 

|POP | SUPER POP | Description                 
|----|-----------|------------------------------------------------------
|FIN | EUR       | Finnish in Finland 	
|CHS | EAS       | Han Chinese South
|GBR | EUR       | British from England and Scotland
|PUR | AMR       | Puerto Rican in Puerto Rico
|CLM | AMR       | Colombian in Medellin, Colombia
|MXL | AMR       | Mexican Ancestry in Los Angeles, California
|TSI | EUR       | Toscani in Italia
|LWK | AFR       | Luhya in Webuye, Kenya
|JPT | EAS       | Japanese in Tokyo, Japan
|IBS | EUR       | Iberian populations in Spain
|PEL | AMR       | Peruvian in Lima, Peru
|CDX | EAS       | Chinese Dai in Xishuangbanna, China
|YRI | AFR       | Yoruba in Ibadan, Nigeria 
|KHV | EAS       | Kinh in Ho Chi Minh City, Vietnam
|ASW | AFR       | African ancestry in Southwest USA
|ACB | AFR       | African Caribbean in Barbados
|CHB | EAS       | Han Chinese in Beijing, China
|GIH | SAS       | Gujarati Indians in Houston, Texas
|GWD | AFR       | Gambian in Western Division, The Gambia
|PJL | SAS       | Punjabi in Lahore,Pakistan
|MSL | AFR       | Mende in Sierra Leone
|BEB | SAS       | Bengali in Bangladesh
|ESN | AFR       | Esan in Nigeria
|STU | SAS       | Sri Lankan Tamil in the UK
|ITU | SAS       | Indian Telugu in the UK
|CEU | EUR       | Utah residents with Northern and Western European ancestry from the CEPH collection


```{r 1000genomes}
plothap <- function(dat, x1, y1)
{
  p1 <- ggplot(dat, aes_string(x = x1, y = y1, color = "super_pop")) +
            geom_point(alpha = 0.3, size = 2) + theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plothap(filter(pca.eigenvec, super_pop != "ADAPT"), "PC1", "PC2")
p2 <- plothap(filter(pca.eigenvec, super_pop != "ADAPT"), "PC3", "PC4")
p3 <- plothap(filter(pca.eigenvec, super_pop != "ADAPT"), "PC5", "PC6")
p4 <- plothap(filter(pca.eigenvec, super_pop != "ADAPT"), "PC7", "PC8")
p5 <- plothap(filter(pca.eigenvec, super_pop != "ADAPT"), "PC9", "PC10")
p6 <- plothap(filter(pca.eigenvec, super_pop != "ADAPT"), "PC11", "PC12")

ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

We can plot our samples with the centroid of the HapMap pops indicated.

```{r hapmap plus adapt}
meanshap <- dplyr::filter(pca.eigenvec, pop != "ADAPT") %>% dplyr::group_by(pop, super_pop) %>% 
            dplyr::select(contains("PC")) %>% summarise_all(funs(mean))

plothapsamp <- function(dat1, dat2, x1, y1)
{
  p1 <- ggplot(dat1, aes_string(x = x1, y = y1, label = "pop")) + 
          geom_point(data = dat2, 
                     aes_string(x = x1, y = y1), alpha = 0.3) + 
          geom_label(aes(fill = pop), colour = "white", fontface = "bold", alpha = 0.4) + 
          theme_pubr(legend = "none")
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}
  
p1 <- plothapsamp(meanshap, filter(pca.eigenvec, pop == "ADAPT"), "PC1", "PC2")
p2 <- plothapsamp(meanshap, filter(pca.eigenvec, pop == "ADAPT"), "PC3", "PC4")
p3 <- plothapsamp(meanshap, filter(pca.eigenvec, pop == "ADAPT"), "PC5", "PC6")
p4 <- plothapsamp(meanshap, filter(pca.eigenvec, pop == "ADAPT"), "PC7", "PC8")
p5 <- plothapsamp(meanshap, filter(pca.eigenvec, pop == "ADAPT"), "PC9", "PC10")
p6 <- plothapsamp(meanshap, filter(pca.eigenvec, pop == "ADAPT"), "PC11", "PC12")

ggarrange(p1, p2, p3, p4, p5, p6,
          nrow = 3, ncol = 2,
          align = "v")
```

We can also plot our Irish, Polish, Italian, and Portuguese samples.
Clearly there is a north-south structure in Europe, captured also by our samples.

```{r samples w/pop}
plothapgroup <- function(dat1, dat2, x1, y1)
{
  p1 <- ggplot(dat1, aes_string(x = x1, y = y1, label = "pop")) + 
          geom_point(data = dat2, aes_string(x = x1, y = y1, color = "FID"), alpha = 0.5) + 
          geom_label(aes(fill = pop), colour = "white", fontface = "bold", alpha = 0.5) +
          theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

eurhap  <- filter(meanshap, super_pop == "EUR")
eursamp <- filter(pca.eigenvec, FID == "Italian" | FID == "Polish" | FID == "Irish" | 
                                FID == "Portuguese")

p1 <- plothapgroup(eurhap, eursamp, "PC1", "PC2")
p2 <- plothapgroup(eurhap, eursamp, "PC3", "PC4")
p3 <- plothapgroup(eurhap, eursamp, "PC5", "PC6")
p4 <- plothapgroup(eurhap, eursamp, "PC7", "PC8")
p5 <- plothapgroup(eurhap, eursamp, "PC9", "PC10")
p6 <- plothapgroup(eurhap, eursamp, "PC11", "PC12")


ggarrange(p1, p2, p3, p4, p5, p6,
          nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "right",
          align = "v")
```

Finally, let's take a look at the admixture analysis.
Based on visual inspection, these are the approximate cluster by geography associations

|Cluster | POP|
|--------|----|
|1       | NEU|
|2       | EAS|
|3       | SAS|
|4       | SEU|
|5       | AMR|
|6       | AFR|

```{r admixture}
groups <- pca.eigenvec[,c(53, 54),drop=FALSE]
groups <- data.frame(lapply(groups, as.character), stringsAsFactors=FALSE)
#This function exports the graph. It is possible to show it here?
p1 <- plotQ(admix, returnplot=T, exportplot=F, quiet=T, basesize=11, showsp=F,
            grplab=groups, ordergrp=TRUE, selgrp="super_pop", sortind="all")
plot(p1$plot[[1]])
```

## Clustering

For the clustering approach, we'll use the super_pop variables from 1000Genomes.
I'll use the reference samples as training, with a 5-fold cross-validation, and predict the values of our samples.

```{r SVM clustering continent, message=FALSE}
set.seed(10)
train <- pca.eigenvec %>% filter(super_pop != "ADAPT")
train <- droplevels(train)
test  <- pca.eigenvec %>% filter(super_pop == "ADAPT") 
test  <- droplevels(test)

# 5-fold repeated cross-validation
fitControl <- trainControl(method = "repeatedcv", number = 5, repeats = 5)
svm.fit    <- train(super_pop ~ PC1 + PC2 + PC3 + PC4 + PC5, method = 'svmRadial', 
                     trControl = fitControl, data = train)

svm.fit
test$continent <- predict(svm.fit, test)
summary(test$continent)
```

Scatter plots of the predicted continent groups 

```{r prediceted plots, fig.height=8}
plotcont <- function(dat, x1, y1)
{
  p1 <- ggplot(dat, aes_string(x = x1, y = y1, color = "continent")) +
            geom_point(alpha = 0.3, size = 2) + theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plotcont(test, "PC1", "PC2")
p2 <- plotcont(test, "PC3", "PC4")
p3 <- plotcont(test, "PC5", "PC6")
p4 <- plotcont(test, "PC7", "PC8")

ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

The next step will be to create a clustering of suthern versus northern european populations, using CEU and TSI as training sets. 
We'll double check our clustering with the samples that we have population information (Irish, Polish, Italian, and Portuguese).

```{r svm cluster europe}
pca.eigenvec$Eur[pca.eigenvec$pop == "CEU" | pca.eigenvec$pop == "FIN" | 
                 pca.eigenvec$pop == "GBR"] <- "NEU"
pca.eigenvec$Eur[pca.eigenvec$pop == "TSI" | pca.eigenvec$pop == "IBS"] <- "SEU"

set.seed(10)
train.eur <- pca.eigenvec %>% filter(super_pop == "EUR")
test.eur  <- filter(test, continent == "EUR")

# 5-fold repeated cross-validation
fitControl  <- trainControl(method = "repeatedcv", number = 5, repeats = 5)
svm.fit.eur <- train(Eur ~ PC1 + PC2 + PC3 + PC4 + PC5, method = 'svmRadial', 
                     trControl = fitControl, data = train.eur)
svm.fit.eur
test.eur$continent <- predict(svm.fit.eur, test.eur)
summary(test.eur$continent)
```

```{r Eur predicted plots, fig.height=8}
p1 <- plotcont(test.eur, "PC1", "PC2")
p2 <- plotcont(test.eur, "PC3", "PC4")
p3 <- plotcont(test.eur, "PC5", "PC6")
p4 <- plotcont(test.eur, "PC7", "PC8")

ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

```{r merging predictions}
levels(test$continent) <- c("AFR", "AMR", "EAS", "EUR", "SAS", "NEU", "SEU")
test$continent[test$continent == 'EUR'] <- test.eur$continent
test$Eur <- NULL
test <- droplevels(test)
summary(test$continent)
```

If we look at the clustering and the admixture proportions, we see this

```{r clusadmixture}
testadmix <- admix[[1]][rownames(admix[[1]]) %in% test$IID,]
meanstest <- testadmix %>% dplyr::group_by(test$continent) %>% summarise_all(funs(mean))
meanstest

groups$cont <- groups$super_pop
groups$cont[pca.eigenvec$IID %in% test$IID ] <- as.character(test$continent)

p1 <- plotQ(admix, returnplot=T, exportplot=F, quiet=T, basesize=11, showsp=F,
            grplab=groups[,2:3], ordergrp=TRUE, sortind="all", selgrp = "cont")
grid.arrange(p1$plot[[1]])
```


## Combining datasets

```{r read facedata, message=FALSE, warning=FALSE}
setwd('..')
path <- getwd()
setwd(paste(path, "/Results/FacePCA", sep = ""))
coeffs   <- read.csv("cleancoeffs.csv")
```

```{r merging, message=FALSE}
colnames(coeffs)[1] <- "IID"
total      <- merge(test, coeffs, by = "IID") 
FacePCA    <- total[,61:147]
GenPCA     <- total[,3:52]
Covariates <- total[,c(1,2,56:60,54,55)]

PCnames <- sprintf("PC%s",seq(1:87))
colnames(FacePCA) <- PCnames

PCnames <- sprintf("PC%s",seq(1:50))
colnames(GenPCA) <- PCnames

MergedDat <- list(Covariates, FacePCA, GenPCA) 

setwd('..')
path <- getwd()
setwd(paste(path, "/Results/MergedData", sep = ""))
save(MergedDat, file = "MergedDat.RData")
```