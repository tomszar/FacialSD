---
title: Genetic PCA
output:
  html_document: default
---

This script will take you to the construction of the Genetic PCA, and the population clustering.
It will merge the final datasets (Facial PCA, Genetic PCA, Covariates, Admixture), in one single data set.

The steps to create the genetic PCA were as following:

- Remove of missing genotype data.
- LD pruning using a window size of 50 SNPs, with 5 SNPs steps, and a VIF of 2.
- Only 1000Genomes samples were used to create the PCA, and our samples were projected there.
- A total of 50 PCs were extracted

## Preliminaries

Libraries

```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(pophelper)
library(caret)
```

Datasets

```{r datasets, message=FALSE, warning=FALSE}
setwd('..')
path <- getwd()

#Calling genetic PCA
setwd(paste(path, "/Results/GenPCA", sep = ""))
gen.eigenval <- read_csv("PCA.eigenval", col_names = F)
gen.eigenvec <- read_delim("PCA.eigenvec", delim = " ", col_names = F)
PCnames      <- sprintf("PC%s",seq(1:50))
colnames(gen.eigenvec) <- c("FID", "IID", PCnames)
gen.eigenvec$FID <- as.character(gen.eigenvec$FID)

#Calling facePCA
setwd(paste(path, "/Results/FacePCA", sep = ""))
face.coeffs   <- read_csv("coeffs.csv")
#face.eigenvec <- read_csv("eigenvectors.csv", col_names = F)
#face.eigenval <- read_csv("eigenvalues.csv", col_names = F)
#face.means    <- read_csv("means.csv", col_names = F)
#face.facets   <- read_csv("facets.csv", col_names = F)
face.coeffs$ID <- as.character(face.coeffs$ID)

#Calling 1000 Genomes sample info
setwd(paste(path, "/DataBases/Genotypes/05_ReferenceSamples", sep = ""))
pops_100g <- read_delim("integrated_call_samples_v3.20130502.ALL.panel", delim = "\t")
colnames(pops_100g)[1] <- "IID"
#Calling HGDP sample info
pops_hgdp <- read_delim("SampleInformation.txt", delim = "\t")
colnames(pops_hgdp)[1] <- "IID"

#Calling admixture analysis
setwd(paste(path, "/Results/Admixture", sep = ""))
gen.admix <- readQ("Merge1000Gsamples.6.Q")
#Removing duplicates
gen.admix[[1]] <- gen.admix[[1]][!duplicated(gen.eigenvec$IID), ] 
gen.eigenvec   <- gen.eigenvec[!duplicated(gen.eigenvec$IID), ] 
rownames(gen.admix[[1]]) <- gen.eigenvec$IID
```

```{r showing data, message=FALSE, warning=FALSE}
print(gen.eigenvec)
print(face.coeffs)
```


## Data cleaning

First we will create super_pop names similar to the ones in the 1000G samples.

```{r super_pop naming}
pops_hgdp     <- pops_hgdp[-nrow(pops_hgdp), ]
pops_hgdp$IID <- as.character(pops_hgdp$IID)

#Changing the HGDP ID name 
for(i in 1:nrow(pops_hgdp)){
  n   <- nchar(pops_hgdp$IID[i])
  ze  <- 5 - n 
  add <- paste0("HGDP", paste(rep("0", ze), collapse = ""))
  pops_hgdp$IID[i] <- paste0(add, pops_hgdp$IID[i])
}

```

Now we will merge the HGDP and 1000G sample info in one dataframe

```{r}
colnames(pops_hgdp)[c(3,5)] <- c("pop", "super_pop")
pops <- bind_rows(pops_100g[,1:3], pops_hgdp[,c(1,3,5)])

#Changing super_pop names
pops$super_pop[pops$super_pop == "AFRICA"]    <- "AFR"
pops$super_pop[pops$super_pop == "AMERICA"]   <- "AMR"
pops$super_pop[pops$super_pop == "EAST_ASIA"] <- "EAS"
pops$super_pop[pops$super_pop == "EUROPE"]    <- "EUR"
pops$super_pop[pops$super_pop == "MIDDLE_EAST"] <- "MDE"
pops$super_pop[pops$super_pop == "OCEANIA"]     <- "OCE"
pops$super_pop[pops$super_pop == "CENTRAL_SOUTH_ASIA"] <- "SAS"
```


Creating new columns to plot 1000G pops against our samples more easily.

```{r new column}
#Adding pop and super_pop names
gen.eigenvec <- gen.eigenvec %>% left_join(pops, by = "IID")
gen.eigenvec <- gen.eigenvec %>% mutate(pop = ifelse(is.na(pop), "ADAPT", pop)) %>% 
                                 mutate(super_pop = ifelse(is.na(super_pop), "ADAPT", super_pop))

gen.eigenvec$pop       <- as.factor(gen.eigenvec$pop)
gen.eigenvec$super_pop <- as.factor(gen.eigenvec$super_pop)
```

Because plink output is a normalized PCA, we de-normalized the PCA by multiplying the eigenvectors by the standard deviation.

```{r de-normalizing PCA}
gen.eigenvec[,3:52] <- t(c(as.matrix(gen.eigenval)) * t(as.matrix(gen.eigenvec[,3:52])))
print(gen.eigenvec)
```

## Clustering

For the clustering approach, we'll use the super_pop variables from 1000Genomes.
I'll use the reference samples as training, with a 5-fold cross-validation, and predict the values of our samples.

```{r SVM clustering continent, message=FALSE}
set.seed(10)

# 5-fold repeated cross-validation
fitControl <- trainControl(method = "repeatedcv", number = 5, repeats = 5)
svm.fit    <- train(super_pop ~ PC1 + PC2 + PC3 + PC4 + PC5, method = 'svmRadial', 
                     trControl = fitControl, data = droplevels(gen.eigenvec %>% 
                                                                 filter(super_pop != "ADAPT")))

svm.fit
#error aca
clusters <- gen.eigenvec %>% filter(super_pop == "ADAPT") %>% select(IID)
clusters <- clusters %>% mutate(prediction = predict(svm.fit, droplevels(gen.eigenvec %>%
                                                    filter(super_pop == "ADAPT") )) ) 
gen.eigenvec <- gen.eigenvec %>% left_join(clusters, by = "IID")
summary(gen.eigenvec$prediction)
```

## Combining datasets

```{r merging, message=FALSE}
colnames(face.coeffs)[1] <- "IID"
total      <- gen.eigenvec %>% inner_join(face.coeffs, by = "IID")
total      <- total %>% filter(Sex == "Male" | Sex == "Female")
FacePCnames <- sprintf("Face_PC%s",seq(1:87))
GenePCnames <- sprintf("Gen_PC%s",seq(1:50))
colnames(total)[62:148] <- FacePCnames
colnames(total)[3:52]   <- GenePCnames
total <- total[,c(1,2,56:61,55,3:52,62:148)]

OneGenomes <- gen.eigenvec %>% filter(pop != "ADAPT") %>% select(-FID, -prediction)
OneGenomes <- OneGenomes %>% select(IID, pop, super_pop, everything())

MergedDat <- list(total, OneGenomes, gen.admix) 

setwd(paste(path, "/Results/MergedData", sep = ""))
save(MergedDat, file = "MergedDat.RData")
```