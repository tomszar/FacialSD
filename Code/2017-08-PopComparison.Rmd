---
output: 
  html_document:
    fig_height: 10
    fig_width: 10
---

In this script we'll look at the difference in patterns of facial sexual dimorphism between the populations previously defined. 
We'll use multivariate statistics to estimate group differences in the face PCA. 
Also, we'll estimate the vectors of FSD, as well as the allometric and non-allometric components between populations. 
To do that, we'll compare the magnitude between vectors (degree of facial sexual dimorphism), and the direction (pattern of facial sexual dimorphism). 


# Preliminaries

Loading libraries

```{r libraries}
library(ggplot2)
library(dplyr)
library(ggpubr)
```

Loading databases

```{r databases}
setwd('..')
path <- getwd()
setwd(paste(path, "/Results/MergedData", sep = ""))
#Read data
load("MergedDat.RData")
```

# Data cleaning

I'll remove participants without Male or Female self-identified sex.
You can see the IID of the participants removed.

```{r data cleaning}
MergedDat[[1]]$IID[!(MergedDat[[1]]$Sex == "Male" | MergedDat[[1]]$Sex == "Female")]
cleanSex       <- MergedDat[[1]]$Sex == "Male" | MergedDat[[1]]$Sex == "Female"
MergedDat[[1]] <- dplyr::filter(MergedDat[[1]], cleanSex)
MergedDat[[2]] <- dplyr::filter(MergedDat[[2]], cleanSex)
MergedDat[[3]] <- dplyr::filter(MergedDat[[3]], cleanSex)
MergedDat[[1]]$Sex <- droplevels(MergedDat[[1]]$Sex)
```


# Descriptive and exploratory analyses

```{r summary}
summary(MergedDat[[1]])
summ <- MergedDat[[1]] %>% group_by(continent, Sex) %>% select(Age, Height, Weight) %>% 
            summarise_all(funs(mean(. , na.rm = T), median(. , na.rm = T), sd(. , na.rm = T)))
tbl_df(summ)
```

We can compare the distributions of PCs for each geographical group

```{r joyplots}
source("PlotPCs.R")
p1 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC1", "PC9")
p2 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC10", "PC19")
p3 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC20", "PC29")
p4 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC30", "PC39")
ggarrange(p1, p2, p3, p4,
          common.legend = TRUE, legend = "right", 
          align = "v")

p1 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC40", "PC49")
p2 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC50", "PC59")
p3 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC60", "PC69")
p4 <- PlotPCs(MergedDat[[2]], MergedDat[[1]]$continent, "PC70", "PC79")
ggarrange(p1, p2, p3, p4,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

# Hypohtesis testing

We'll test whether group averages differ between groups, by using a 5x2 design using continent and Sex as grouping variables.
As shown, both continet and Sex (and their interaction) are significant predictors of face shape.

```{r MANOVA}
fit <- manova(as.matrix(MergedDat[[2]]) ~ MergedDat[[1]]$Sex * MergedDat[[1]]$continent)
summary(fit, test="Pillai")
library(vegan)
fit2 <- adonis(as.matrix(MergedDat[[2]]) ~ Sex * continent, data = MergedDat[[1]], permutations = 100, 
               method = "euclidean")
```

We can also compute pairwise mahalanobis distance as a measure of effect size.
Let's see first the distances between continents.
As shown, Asia is the least similar groups overall

```{r mahal continent}
library(HDMD)
madistcont <- pairwise.mahalanobis(MergedDat[[2]], MergedDat[[1]]$continent)
dimnames(madistcont$distance) <- list(levels(MergedDat[[1]]$continent), levels(MergedDat[[1]]$continent))
madistcont$distance
plot(hclust(as.dist(madistcont$distance)))
```

We can use the full 5 X 2 design to evaluate the overall distance between continental group divided by males and females
As seen in the dendogram, African and Asian faces cluster together, while American and European females, and American and European males form another cluster. 
Interestingly, American and European females cluster closer to the African branch.
Also, the continental group with the least difference between sexes is America, while the other groups have similar values.

```{r mahalanobis dist}
madist <- pairwise.mahalanobis(MergedDat[[2]], interaction(MergedDat[[1]]$continent, MergedDat[[1]]$Sex))
dimnames(madist$distance) <- list(levels(interaction(MergedDat[[1]]$continent, MergedDat[[1]]$Sex)),
                                  levels(interaction(MergedDat[[1]]$continent, MergedDat[[1]]$Sex)))
madist$distance
plot(hclust(as.dist(madist$distance)))
```


# Vectors comparison

Another approach is to calculate the sexual dimorphism vectors for each population, and compare them.
We can compare the magnitude and angle between vectors to assess the degree and pattern of facial sexual dimorphism respectively.
First, let's look at the position of each consensus face (continent x Sex).
As seen in the first four PCs, Asian faces seem more divergent in the face space, corroborating the dendogram results.
Also, looking at the male-female pairs, we see a similar direction in the first two PCs, while lower PCs seem to diverge more.

```{r vector calculation}
consensus <- MergedDat[[2]] %>% group_by(MergedDat[[1]]$continent, MergedDat[[1]]$Sex) %>%
             summarise_all(funs(mean))
colnames(consensus)[c(1,2)] <- c("continent", "Sex")
consensus$groups <- paste(consensus$continent, consensus$Sex, sep = ".")

plotsdmeans <- function(PCA, x1, y1) 
{ 
  p1 <- ggplot(PCA, aes_string(x = x1, y = y1)) + 
            geom_point(alpha = 0.05) +
            geom_point(data = consensus, 
                       aes_string(
                         x = x1, y = y1,
                         color = "consensus$groups"), 
                       size = 4) +
            scale_color_discrete(name = "Groups") +
            theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plotsdmeans(MergedDat[[2]], "PC1", "PC2")
p2 <- plotsdmeans(MergedDat[[2]], "PC3", "PC4")
p3 <- plotsdmeans(MergedDat[[2]], "PC5", "PC6")
p4 <- plotsdmeans(MergedDat[[2]], "PC7", "PC8")
ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")
```

We can obtain the vector of total sexual dimorphism by substracting the female to the male consensus face.
To obtain the allometric component, we run a multivariate linear regression of face shape against Sex, Height, and continent. 
Also, we can compute manova tables to estimate the effect of Sex, Height, and continent on face shape (face PCs).
In this case, we'll also estimate the Height by continent interaction, so as to compare the vectors between continental groups, if not, they would have the same vector.

```{r SD decomposition}
#TOTAL SD
totalSD <- matrix(0, ncol = 88, nrow = 5)
totalSD <- data.frame(totalSD)
totalSD[,1] <- levels(consensus$continent)
colnames(totalSD) <- c("continent", colnames(MergedDat[[2]]))

row <- 1
for(i in seq(1, 10, 2)){
  totalSD[row, 2:88] <- consensus[i, 3:89] - consensus[i+1, 3:89] 
  row = row + 1
}

#ALLOMETRIC SD
fit <- lm(as.matrix(MergedDat[[2]]) ~ MergedDat[[1]]$Sex + MergedDat[[1]]$Height * MergedDat[[1]]$continent)
summary(manova(fit))
alloSD <- totalSD
for(cont in 1:length(levels(MergedDat[[1]]$continent)))
{
  pca  <- dplyr::filter(MergedDat[[2]], MergedDat[[1]]$continent == levels(MergedDat[[1]]$continent)[cont])
  covs <- dplyr::filter(MergedDat[[1]], continent == levels(MergedDat[[1]]$continent)[cont])
  fit  <- lm(as.matrix(pca) ~ covs$Sex + covs$Height)
  alloSD[cont,2:88] <- coef(fit)[3,] * (mean(covs[covs$Sex == 'Female',5], na.rm = T) - 
                                          mean(covs[covs$Sex == 'Male',5], na.rm = T))
}

#NON ALLOMETRIC
nonalloSD <- totalSD
nonalloSD[,2:88] <- totalSD[,2:88] - alloSD[,2:88]

```


```{r vector plots}
plotvect <- function(PCA, x1, y1, vectors)
{
  p1 <- ggplot(PCA, aes_string(x = x1, y = y1)) +
            geom_point(alpha = 0.05) + 
            geom_segment(data = vectors, 
                         aes_string(x = 0, y = 0,
                                    xend = paste(x1, "*3", sep = ""), 
                                    yend = paste(y1, "*3", sep = ""),
                                    color = "continent"), 
                 arrow = arrow(length = unit(0.03, "npc")), size = 1) +
            scale_color_discrete(name = "Continent") + 
            theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plotvect(MergedDat[[2]], "PC1", "PC2", totalSD)
p2 <- plotvect(MergedDat[[2]], "PC3", "PC4", totalSD)
p3 <- plotvect(MergedDat[[2]], "PC5", "PC6", totalSD)
p4 <- plotvect(MergedDat[[2]], "PC7", "PC8", totalSD)
p5 <- plotvect(MergedDat[[2]], "PC9", "PC10", totalSD)
p6 <- plotvect(MergedDat[[2]], "PC11", "PC12", totalSD)
ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")

p1 <- plotvect(MergedDat[[2]], "PC1", "PC2", alloSD)
p2 <- plotvect(MergedDat[[2]], "PC3", "PC4", alloSD)
p3 <- plotvect(MergedDat[[2]], "PC5", "PC6", alloSD)
p4 <- plotvect(MergedDat[[2]], "PC7", "PC8", alloSD)
p5 <- plotvect(MergedDat[[2]], "PC9", "PC10", alloSD)
p6 <- plotvect(MergedDat[[2]], "PC11", "PC12", alloSD)
ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")

p1 <- plotvect(MergedDat[[2]], "PC1", "PC2", nonalloSD)
p2 <- plotvect(MergedDat[[2]], "PC3", "PC4", nonalloSD)
p3 <- plotvect(MergedDat[[2]], "PC5", "PC6", nonalloSD)
p4 <- plotvect(MergedDat[[2]], "PC7", "PC8", nonalloSD)
p5 <- plotvect(MergedDat[[2]], "PC9", "PC10", nonalloSD)
p6 <- plotvect(MergedDat[[2]], "PC11", "PC12", nonalloSD)
ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")
```


Angles between total SD vectors

```{r}
source("Distances.R")
levels(consensus$continent)
ma <- getPAngle(totalSD[,2:88])
ma
plot(hclust(as.dist(ma)))

```

We can compute the angle between the total an allometric SD for each group.

```{r total allo angle}
ang <- getPAngle(rbind(totalSD[,2:88], alloSD[,2:88]))
ang
```


Calculating the magnitude of each vector

```{r}
apply(totalSD[,2:88], 1, function(x) as.numeric(x) %*% as.numeric(x))
apply(alloSD[,2:88], 1, function(x) as.numeric(x) %*% as.numeric(x))
apply(nonalloSD[,2:88], 1, function(x) as.numeric(x) %*% as.numeric(x))
```

