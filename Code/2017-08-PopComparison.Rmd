---
output: 
  html_document:
    fig_height: 10
    fig_width: 10
title: Population comparisons
---

In this script we'll look at the difference in patterns of facial sexual dimorphism between the populations previously defined. 
We'll use multivariate statistics to estimate group differences in the face PCA. 
Also, we'll estimate the vectors of FSD, as well as the allometric and non-allometric components between populations. 
To do that, we'll compare the magnitude between vectors (degree of facial sexual dimorphism), and the direction (pattern of facial sexual dimorphism). 


## Preliminaries

Loading libraries and databases

```{r libraries data, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(ggpubr)
library(vegan)
library(HDMD)
setwd('..')
path <- getwd()
setwd(paste(path, "/Results/MergedData", sep = ""))
#Read data
load("MergedDat.RData")
```

## Data cleaning

I'll remove participants without Male or Female self-identified sex.
You can see the IID of the participants removed.

```{r data cleaning}
MergedDat[[1]]$IID[!(MergedDat[[1]]$Sex == "Male" | MergedDat[[1]]$Sex == "Female")]
cleanSex       <- MergedDat[[1]]$Sex == "Male" | MergedDat[[1]]$Sex == "Female"
MergedDat[[1]] <- dplyr::filter(MergedDat[[1]], cleanSex)
MergedDat[[2]] <- dplyr::filter(MergedDat[[2]], cleanSex)
MergedDat[[3]] <- dplyr::filter(MergedDat[[3]], cleanSex)
MergedDat[[1]]$Sex <- droplevels(MergedDat[[1]]$Sex)
```


## Descriptive and exploratory analyses

```{r summary}
summary(MergedDat[[1]])
summ <- MergedDat[[1]] %>% group_by(continent, Sex) %>% dplyr::select(Age, Height, Weight) %>% 
            summarise_all(funs(mean(. , na.rm = T), median(. , na.rm = T), sd(. , na.rm = T)))
tbl_df(summ)
```

We can compare the distributions of PCs for each geographical group using joy plots.
Note that the PCA has been scaled.

```{r joyplots, message=FALSE}
source("PlotPCs.R")
ts <- as.data.frame(scale(MergedDat[[2]]))
p1 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC1", "PC9")
p2 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC10", "PC19")
p3 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC20", "PC29")
p4 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC30", "PC39")
ggarrange(p1, p2, p3, p4,
          common.legend = TRUE, legend = "right", 
          align = "v")

p1 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC40", "PC49")
p2 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC50", "PC59")
p3 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC60", "PC69")
p4 <- PlotPCs(ts, MergedDat[[1]]$continent, "PC70", "PC79")
ggarrange(p1, p2, p3, p4,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

We can also see the distribution in the first PCs of sexes by each continental group

```{r sexes by continent plots, fig.height = 14, fig.width = 10}
plotsexes <- function(PCA, cont, x1, y1)
{
  highPCA <- filter(PCA, cont)
  backPCA <- filter(PCA, !cont)
  sexes   <- filter(MergedDat[[1]], cont)$Sex
  title   <- as.character(MergedDat[[1]]$continent[cont][1])
  p1 <- ggplot(highPCA, aes_string(x = x1, y = y1)) + 
            geom_point(aes(color = sexes)) + 
            geom_point(data = backPCA, alpha = 0.01, aes_string(x = x1, y = y1)) + 
            theme_pubr() + 
            ggtitle(title)
  p1 <- ggpar(p1, palette = "jco")
  return(p1)
}

p1 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "AFR", "PC1", "PC2")
p2 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "AFR", "PC3", "PC4")
p3 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "AMR", "PC1", "PC2")
p4 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "AMR", "PC3", "PC4")
p5 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "EAS", "PC1", "PC2")
p6 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "EAS", "PC3", "PC4")
p7 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "SAS", "PC1", "PC2")
p8 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "SAS", "PC3", "PC4")
p9 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "NEU", "PC1", "PC2")
p10 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "NEU", "PC3", "PC4")
p11 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "SEU", "PC1", "PC2")
p12 <- plotsexes(MergedDat[[2]], MergedDat[[1]]$continent == "SEU", "PC3", "PC4")

ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, 
          ncol = 2, nrow = 6,
          common.legend = TRUE, legend = "bottom", 
          align = "v")
```


## Hypohtesis testing

It is clear from the scatter plots that Asian and South Asian samples differ substantially in their sample size. 
This could affect our estimations for differences.
For example, when estimating location differences between the groups, it is not possible to ascertain that that difference is due to location or dispersion, which may be affected by unbalanced data sets. 
Therefore, we'll first remove Asian samples from our location difference tests.
We'll test whether group averages differ between groups, by using a 5x2 design using continent and Sex as grouping variables.
As shown, both continent and Sex (and their interaction) are significant predictors of face shape.


```{r MANOVA}
fit <- manova(as.matrix(MergedDat[[2]]) ~ MergedDat[[1]]$Sex * MergedDat[[1]]$continent)
summary(fit)

fitsub <- manova(as.matrix(MergedDat[[2]][,1:10]) ~ MergedDat[[1]]$Sex * MergedDat[[1]]$continent)
summary(fitsub)

#mahamatrix <- vegdist(MergedDat[[2]], method = "mahalanobis")
#fit2 <- betadisper(mahamatrix, MergedDat[[1]]$continent)
#plot(fit2)
#permutest(fit2, pairwise = T)

#fit2 <- adonis(as.matrix(MergedDat[[2]]) ~ MergedDat[[1]]$Sex * MergedDat[[1]]$continent, permutations = 999, 
#               method = "mahalanobis")
#fit2
```

We can also compute pairwise mahalanobis distance as a measure of effect size.
This is preferred from an Euclidean distance, because the within-group variation is taken into account in the mahalanobis distance.
As shown in the dendogram, EAS is the least similar group overall.

```{r mahal continent}
madistcont <- pairwise.mahalanobis(MergedDat[[2]], MergedDat[[1]]$continent)
dimnames(madistcont$distance) <- list(levels(MergedDat[[1]]$continent), levels(MergedDat[[1]]$continent))
madistcont$distance
plot(hclust(as.dist(madistcont$distance)))
```

We can use the full 5 X 2 design to evaluate the overall distance between continental group divided by males and females
As seen in the dendogram, African and Asian faces cluster together, while American and European females, and American and European males form another cluster. 
Interestingly, American and European females cluster closer to the African branch.
Also, the continental group with the least difference between sexes is America, while the other groups have similar values.

```{r mahalanobis dist}
madist <- pairwise.mahalanobis(MergedDat[[2]], interaction(MergedDat[[1]]$continent, MergedDat[[1]]$Sex))
dimnames(madist$distance) <- list(levels(interaction(MergedDat[[1]]$continent, MergedDat[[1]]$Sex)),
                                  levels(interaction(MergedDat[[1]]$continent, MergedDat[[1]]$Sex)))
madist$distance
plot(hclust(as.dist(madist$distance)))
```


## Vectors comparison

Another approach is to calculate the sexual dimorphism vectors for each population, and compare them.
We can compare the magnitude and angle between vectors to assess the degree and pattern of facial sexual dimorphism respectively.
For the pattern of SD (angle) we can use the cosine similarity measure to assess statistical significance of pairwise comparisons. 
We can use permutation (permuting continent labels) to assess statistical significance.
First, let's look at the position of each consensus face (continent x Sex).
As seen in the first four PCs, Asian faces seem more divergent in the face space, corroborating the dendogram results.
Also, looking at the male-female pairs, we see a similar direction in the first two PCs, while lower PCs seem to diverge more.

```{r vector calculation}
consensus <- MergedDat[[2]] %>% group_by(MergedDat[[1]]$continent, MergedDat[[1]]$Sex) %>%
             summarise_all(funs(mean))
colnames(consensus)[c(1,2)] <- c("continent", "Sex")
consensus$groups <- paste(consensus$continent, consensus$Sex, sep = ".")

plotsdmeans <- function(PCA, x1, y1) 
{ 
  p1 <- ggplot(PCA, aes_string(x = x1, y = y1)) + 
            geom_point(alpha = 0.05) +
            geom_point(data = consensus, 
                       aes_string(
                         x = x1, y = y1,
                         color = "consensus$groups"), 
                       size = 4) +
            scale_color_discrete(name = "Groups") +
            theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plotsdmeans(MergedDat[[2]], "PC1", "PC2")
p2 <- plotsdmeans(MergedDat[[2]], "PC3", "PC4")
p3 <- plotsdmeans(MergedDat[[2]], "PC5", "PC6")
p4 <- plotsdmeans(MergedDat[[2]], "PC7", "PC8")
ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")
```

We can obtain the vector of total sexual dimorphism by subtracting the female to the male consensus face.
To obtain the allometric component, we run a multivariate linear regression of face shape against Sex, Height, and continent. 
Also, we can compute manova tables to estimate the effect of Sex, Height, and continent on face shape (face PCs).
In this case, we'll also estimate the Height by continent interaction, so as to compare the vectors between continental groups, if not, they would have the same vector.

```{r SD decomposition}
#TOTAL SD
totalSD <- matrix(0, ncol = 88, nrow = 6)
totalSD <- data.frame(totalSD)
totalSD[,1] <- levels(consensus$continent)
colnames(totalSD) <- c("continent", colnames(MergedDat[[2]]))

row <- 1
for(i in seq(1, 12, 2)){
  totalSD[row, 2:88] <- consensus[i, 3:89] - consensus[i+1, 3:89] 
  row = row + 1
}

#ALLOMETRIC SD
fit <- lm(as.matrix(MergedDat[[2]]) ~ MergedDat[[1]]$Sex + MergedDat[[1]]$Height *    
                                      MergedDat[[1]]$continent)
summary(manova(fit))
alloSD <- totalSD
for(cont in 1:length(levels(MergedDat[[1]]$continent)))
{
  pca  <- dplyr::filter(MergedDat[[2]], MergedDat[[1]]$continent == levels(MergedDat[[1]]$continent)[cont])
  covs <- dplyr::filter(MergedDat[[1]], continent == levels(MergedDat[[1]]$continent)[cont])
  fit  <- lm(as.matrix(pca) ~ covs$Sex + covs$Height)
  alloSD[cont,2:88] <- coef(fit)[3,] * (mean(covs[covs$Sex == 'Female',5], na.rm = T) - 
                                          mean(covs[covs$Sex == 'Male',5], na.rm = T))
}

#NON ALLOMETRIC
nonalloSD <- totalSD
nonalloSD[,2:88] <- totalSD[,2:88] - alloSD[,2:88]

```


```{r vector plots}
plotvect <- function(PCA, x1, y1, vectors)
{
  p1 <- ggplot(PCA, aes_string(x = x1, y = y1)) +
            geom_point(alpha = 0.05) + 
            geom_segment(data = vectors, 
                         aes_string(x = 0, y = 0,
                                    xend = paste(x1, "*3", sep = ""), 
                                    yend = paste(y1, "*3", sep = ""),
                                    color = "continent"), 
                 arrow = arrow(length = unit(0.03, "npc")), size = 1) +
            scale_color_discrete(name = "Continent") + 
            theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plotvect(MergedDat[[2]], "PC1", "PC2", totalSD)
p2 <- plotvect(MergedDat[[2]], "PC3", "PC4", totalSD)
p3 <- plotvect(MergedDat[[2]], "PC5", "PC6", totalSD)
p4 <- plotvect(MergedDat[[2]], "PC7", "PC8", totalSD)
p5 <- plotvect(MergedDat[[2]], "PC9", "PC10", totalSD)
p6 <- plotvect(MergedDat[[2]], "PC11", "PC12", totalSD)
ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")

p1 <- plotvect(MergedDat[[2]], "PC1", "PC2", alloSD)
p2 <- plotvect(MergedDat[[2]], "PC3", "PC4", alloSD)
p3 <- plotvect(MergedDat[[2]], "PC5", "PC6", alloSD)
p4 <- plotvect(MergedDat[[2]], "PC7", "PC8", alloSD)
p5 <- plotvect(MergedDat[[2]], "PC9", "PC10", alloSD)
p6 <- plotvect(MergedDat[[2]], "PC11", "PC12", alloSD)
ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")

p1 <- plotvect(MergedDat[[2]], "PC1", "PC2", nonalloSD)
p2 <- plotvect(MergedDat[[2]], "PC3", "PC4", nonalloSD)
p3 <- plotvect(MergedDat[[2]], "PC5", "PC6", nonalloSD)
p4 <- plotvect(MergedDat[[2]], "PC7", "PC8", nonalloSD)
p5 <- plotvect(MergedDat[[2]], "PC9", "PC10", nonalloSD)
p6 <- plotvect(MergedDat[[2]], "PC11", "PC12", nonalloSD)
ggarrange(p1, p2, p3, p4, p5, p6, nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "top", 
          align = "v")
```


Angles between total SD vectors

```{r}
source("Distances.R")
levels(consensus$continent)
ma <- getPAngle(totalSD[,2:88])
ma
plot(hclust(as.dist(ma)))

#Not working
#nulls <- getAngleperm(MergedDat[[2]], MergedDat[[1]]$Sex, MergedDat[[1]]$continent)
#pvals <- 
#  for(i in 1:(nrow(nulls)))
#  {
#    
#  }
#sum(ma[1,2] < nulls[1,])/1000
#sum(ma[1,3] < nulls[2,])/1000
#sum(ma[1,4] < nulls[3,])/1000
#sum(ma[1,5] < nulls[4,])/1000
#sum(ma[2,3] < nulls[5,])/1000
#sum(ma[2,4] < nulls[6,])/1000
#sum(ma[2,5] < nulls[7,])/1000
#sum(ma[3,4] < nulls[8,])/1000
#sum(ma[3,5] < nulls[9,])/1000
#sum(ma[4,5] < nulls[10,])/1000
```

We can compute the angle between the total an allometric SD for each group.

```{r total allo angle}
ang <- getPAngle(rbind(totalSD[,2:88], alloSD[,2:88]))
ang
```


Calculating the magnitude of each vector

```{r}
apply(totalSD[,2:88], 1, function(x) as.numeric(x) %*% as.numeric(x))
apply(alloSD[,2:88], 1, function(x) as.numeric(x) %*% as.numeric(x))
apply(nonalloSD[,2:88], 1, function(x) as.numeric(x) %*% as.numeric(x))
```

